import{_ as d,c as u,a,b as r,e as s,f as o,d as t,r as l,o as h}from"./app-18xufYXV.js";const v="/cs-guide/assets/inorder-CST6uHxL.gif",g="/cs-guide/assets/preorder-C4Kw2VyP.gif",p="/cs-guide/assets/postorder-CSRgBrfC.gif",f="/cs-guide/assets/level-order-mcB_0qBS.gif",b={},m={class:"table-of-contents"};function c(w,e){const n=l("router-link"),i=l("RouteLink");return h(),u("div",null,[e[19]||(e[19]=a('<h1 id="binary-tree-traversal" tabindex="-1"><a class="header-anchor" href="#binary-tree-traversal"><span>Binary Tree Traversal</span></a></h1><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><p>Now that we&#39;ve discussed Trees and how they work, what if you&#39;d want to find a specific value in a node? For arrays, this is easy: just iterate over the array. For Stacks and Queues, just continually check if the Stack or Queue is empty and continuously <code>pop()</code> or <code>dequeue()</code>, respectively. But, what about for Trees? It looks quite complex to traverse this data structure to check for a value.</p><p>In this section, we will discuss the various ways we can traverse a binary tree.</p><h3 id="table-of-contents" tabindex="-1"><a class="header-anchor" href="#table-of-contents"><span>Table of Contents</span></a></h3>',5)),r("nav",m,[r("ul",null,[r("li",null,[s(n,{to:"#introduction"},{default:o(()=>e[0]||(e[0]=[t("Introduction")])),_:1}),r("ul",null,[r("li",null,[s(n,{to:"#table-of-contents"},{default:o(()=>e[1]||(e[1]=[t("Table of Contents")])),_:1})])])]),r("li",null,[s(n,{to:"#inorder-traversal"},{default:o(()=>e[2]||(e[2]=[t("Inorder Traversal")])),_:1})]),r("li",null,[s(n,{to:"#preorder-traversal"},{default:o(()=>e[3]||(e[3]=[t("Preorder Traversal")])),_:1})]),r("li",null,[s(n,{to:"#postorder-traversal"},{default:o(()=>e[4]||(e[4]=[t("Postorder Traversal")])),_:1})]),r("li",null,[s(n,{to:"#level-order-traversal-breadth-first-search"},{default:o(()=>e[5]||(e[5]=[t("Level Order Traversal (Breadth-first Search)")])),_:1})])])]),e[20]||(e[20]=a('<h2 id="inorder-traversal" tabindex="-1"><a class="header-anchor" href="#inorder-traversal"><span>Inorder Traversal</span></a></h2><p>In <strong>Inorder</strong> traversal, we traverse the left subtree, then the root, then the right subtree. In this traversal method, we go &quot;up&quot; the left subtree, then the root, then go &quot;down&quot; the right subtree.</p><p>Here, <strong>blue</strong> means the nodes that are being recursively visited, while <strong>green</strong> means checking the value of the node.</p><img src="'+v+'" class="center x50"><p>From the order of our &quot;green&quot; nodes, the resulting sequence should be: H D I B E J A K F C G</p><h2 id="preorder-traversal" tabindex="-1"><a class="header-anchor" href="#preorder-traversal"><span>Preorder Traversal</span></a></h2><p>In <strong>Preorder</strong> traversal, we traverse from the root, then the left subtree, then the right subtree. In this traversal method, we go &quot;down&quot; in both the left subtree and the right subtree.</p><p>Again, <strong>blue</strong> means the nodes that are being recursively visited, while <strong>green</strong> means checking the value of the node.</p><img src="'+g+'" class="center x50"><p>From the order of our &quot;green&quot; nodes, the resulting sequence should be: A B D H I E J C F K G</p><h2 id="postorder-traversal" tabindex="-1"><a class="header-anchor" href="#postorder-traversal"><span>Postorder Traversal</span></a></h2><p>In <strong>Postorder</strong> traversal, we traverse from the left subtree, the root, then the right subtree. In this traversal method, we go &quot;up&quot; in both the left and right subtree, the inverse of <a href="#preorder-traversal">Preorder Traversal</a>.</p><p>Again, <strong>blue</strong> means the nodes that are being recursively visited, while <strong>green</strong> means checking the value of the node.</p><img src="'+p+'" class="center x50"><p>From the order of our &quot;green&quot; nodes, the resulting sequence should be: H I D J E B K F G C A</p><h2 id="level-order-traversal-breadth-first-search" tabindex="-1"><a class="header-anchor" href="#level-order-traversal-breadth-first-search"><span>Level Order Traversal (Breadth-first Search)</span></a></h2>',16)),r("p",null,[e[7]||(e[7]=t("In ")),e[8]||(e[8]=r("strong",null,"Level Order Traversal",-1)),e[9]||(e[9]=t(", also known as ")),e[10]||(e[10]=r("strong",null,"Breadth-first Search",-1)),e[11]||(e[11]=t(" or ")),e[12]||(e[12]=r("strong",null,"BFS",-1)),e[13]||(e[13]=t(", we create a ")),s(i,{to:"/cs5/3/adt-stack-and-queue.html#queue"},{default:o(()=>e[6]||(e[6]=[t("Queue")])),_:1}),e[14]||(e[14]=t(" that holds the nodes to be visited, and push the root node to the the ")),e[15]||(e[15]=r("strong",null,"Queue",-1)),e[16]||(e[16]=t(". While there is an item in the Queue, we continuously ")),e[17]||(e[17]=r("strong",null,"dequeue",-1)),e[18]||(e[18]=t(" the current node and get all of it's child nodes and append it to the queue, in the order of left to right."))]),e[21]||(e[21]=r("p",null,"When there are no more child nodes, that means that the current node is a leaf, and that we've reached the end of the subtree.",-1)),e[22]||(e[22]=r("p",null,"Unlike the other traversal methods discussed in this section, this traversal method takes advantage of a Queue, rather than recursing on the subnodes.",-1)),e[23]||(e[23]=r("p",null,[t("Again, "),r("strong",null,"blue"),t(" means the nodes that are being recursively visited, while "),r("strong",null,"green"),t(" means checking the value of the node.")],-1)),e[24]||(e[24]=r("img",{src:f,class:"center x50"},null,-1)),e[25]||(e[25]=r("p",null,'From the order of our "green" nodes, the resulting sequence should be: A B C D E F G H I J K',-1))])}const k=d(b,[["render",c],["__file","binary-tree-traversal.html.vue"]]),q=JSON.parse('{"path":"/cs5/3/binary-tree-traversal.html","title":"Binary Tree Traversal","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[{"level":3,"title":"Table of Contents","slug":"table-of-contents","link":"#table-of-contents","children":[]}]},{"level":2,"title":"Inorder Traversal","slug":"inorder-traversal","link":"#inorder-traversal","children":[]},{"level":2,"title":"Preorder Traversal","slug":"preorder-traversal","link":"#preorder-traversal","children":[]},{"level":2,"title":"Postorder Traversal","slug":"postorder-traversal","link":"#postorder-traversal","children":[]},{"level":2,"title":"Level Order Traversal (Breadth-first Search)","slug":"level-order-traversal-breadth-first-search","link":"#level-order-traversal-breadth-first-search","children":[]}],"git":{"updatedTime":1740063889000},"filePathRelative":"cs5/3/binary-tree-traversal.md"}');export{k as comp,q as data};
