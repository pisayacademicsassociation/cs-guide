import{_ as s,c as a,a as o,b as t,e as r,f as i,r as u,o as h,d as n}from"./app-CBXl5LzQ.js";const d={},c={class:"table-of-contents"};function p(f,e){const l=u("router-link");return h(),a("div",null,[e[5]||(e[5]=o('<h1 id="binary-search-tree" tabindex="-1"><a class="header-anchor" href="#binary-search-tree"><span>Binary Search Tree</span></a></h1><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><h3 id="table-of-contents" tabindex="-1"><a class="header-anchor" href="#table-of-contents"><span>Table of Contents</span></a></h3>',3)),t("nav",c,[t("ul",null,[t("li",null,[r(l,{to:"#introduction"},{default:i(()=>e[0]||(e[0]=[n("Introduction")])),_:1}),t("ul",null,[t("li",null,[r(l,{to:"#table-of-contents"},{default:i(()=>e[1]||(e[1]=[n("Table of Contents")])),_:1})])])]),t("li",null,[r(l,{to:"#notes-outline"},{default:i(()=>e[2]||(e[2]=[n("Notes Outline")])),_:1}),t("ul",null,[t("li",null,[r(l,{to:"#recap"},{default:i(()=>e[3]||(e[3]=[n("Recap")])),_:1})]),t("li",null,[r(l,{to:"#binary-search-tree-operations"},{default:i(()=>e[4]||(e[4]=[n("Binary Search Tree operations")])),_:1})])])])])]),e[6]||(e[6]=o('<h2 id="notes-outline" tabindex="-1"><a class="header-anchor" href="#notes-outline"><span>Notes Outline</span></a></h2><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>All notes from this point on are in &quot;raw format&quot;, meaning that the current explanations for them will be <em>pure</em> text, and is most likely in the <em>outline format</em> note-taking method.</p><p>Sadly, due to time constraints, no visual aids or other imagery will exist as of the current moment, and will be added in a future time.</p></div><h3 id="recap" tabindex="-1"><a class="header-anchor" href="#recap"><span>Recap</span></a></h3><ul><li>left subtree <ul><li><strong>all</strong> values lesser than root</li><li>all values <strong>in the subtree</strong> are lesser than the current root.</li></ul></li><li>right subtree <ul><li><strong>all</strong> values higher than root</li><li>all values <strong>in the subtree</strong> are higher than the current root.</li></ul></li></ul><h3 id="binary-search-tree-operations" tabindex="-1"><a class="header-anchor" href="#binary-search-tree-operations"><span>Binary Search Tree operations</span></a></h3><ul><li>search <ul><li>let k be current value</li><li>if k is lesser than the root value <ul><li>go to left node</li></ul></li><li>otherwise, if k is greater than the root value <ul><li>go to right node</li></ul></li><li>if said nodes do not exist, return false (not in tree)</li></ul></li><li>insertion <ul><li>same algorithm as search, except:</li><li>if the node does not exist, add k as the node.</li></ul></li><li>deletion <ul><li>case 1: no children <ul><li>no other effect</li></ul></li><li>case 2: single child <ul><li>child node &quot;takes the place&quot; of it&#39;s parent node.</li></ul></li><li>case 3: both children exist <ul><li>the parent node&#39;s value is replaced with the value of it&#39;s inorder predecessor or successor <ul><li>inorder predecessor, meaning: the previous element to the parent node by inorder traversal</li><li>inorder successor, meaning: the next element to the parent node by inorder traversal <ul><li>the &quot;leftmost&quot; right child (inorder sucessor) <ul><li>Inorder traversal: left subtree -&gt; root -&gt; right subtree.</li><li>However, the right subtree is also traversed inorder, meaning that the left subtree is chosen until no child node exists.</li><li>Therefore, this will be the &quot;leftmost&quot; node on the tree.</li></ul></li><li>the &quot;rightmost&quot; left child (inorder predecessor) <ul><li>Inorder traversal: left subtree, then root</li><li>However, the left subtree is also traversed inorder, which means that it&#39;s traversal is: left subtree -&gt; root -&gt; right subtree</li><li>Therefore, this will be the &quot;rightmost&quot; node on the tree.</li></ul></li></ul></li><li>inorder sucessor is needed only when there us a right child</li><li>you can use <strong>either</strong> the inorder precedessor or sucessor.</li></ul></li></ul></li></ul></li></ul>',6))])}const g=s(d,[["render",p],["__file","binary-search-tree.html.vue"]]),m=JSON.parse('{"path":"/cs5/3/binary-search-tree.html","title":"Binary Search Tree","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[{"level":3,"title":"Table of Contents","slug":"table-of-contents","link":"#table-of-contents","children":[]}]},{"level":2,"title":"Notes Outline","slug":"notes-outline","link":"#notes-outline","children":[{"level":3,"title":"Recap","slug":"recap","link":"#recap","children":[]},{"level":3,"title":"Binary Search Tree operations","slug":"binary-search-tree-operations","link":"#binary-search-tree-operations","children":[]}]}],"git":{"updatedTime":1741096210000},"filePathRelative":"cs5/3/binary-search-tree.md"}');export{g as comp,m as data};
