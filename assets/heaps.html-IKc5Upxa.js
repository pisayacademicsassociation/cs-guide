import{_ as o,c as p,a as i,b as t,e as l,f as n,r as h,o as r,d as s}from"./app-CBXl5LzQ.js";const u={},d={class:"table-of-contents"};function m(c,e){const a=h("router-link");return r(),p("div",null,[e[5]||(e[5]=i('<h1 id="heaps" tabindex="-1"><a class="header-anchor" href="#heaps"><span>Heaps</span></a></h1><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><h3 id="table-of-contents" tabindex="-1"><a class="header-anchor" href="#table-of-contents"><span>Table of Contents</span></a></h3>',3)),t("nav",d,[t("ul",null,[t("li",null,[l(a,{to:"#introduction"},{default:n(()=>e[0]||(e[0]=[s("Introduction")])),_:1}),t("ul",null,[t("li",null,[l(a,{to:"#table-of-contents"},{default:n(()=>e[1]||(e[1]=[s("Table of Contents")])),_:1})])])]),t("li",null,[l(a,{to:"#notes-outline"},{default:n(()=>e[2]||(e[2]=[s("Notes Outline")])),_:1}),t("ul",null,[t("li",null,[l(a,{to:"#heaps-1"},{default:n(()=>e[3]||(e[3]=[s("Heaps")])),_:1})]),t("li",null,[l(a,{to:"#heapq"},{default:n(()=>e[4]||(e[4]=[s("heapq")])),_:1})])])])])]),e[6]||(e[6]=i('<h2 id="notes-outline" tabindex="-1"><a class="header-anchor" href="#notes-outline"><span>Notes Outline</span></a></h2><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>All notes from this point on are in &quot;raw format&quot;, meaning that the current explanations for them will be <em>pure</em> text, and is most likely in the <em>outline format</em> note-taking method.</p><p>Sadly, due to time constraints, no visual aids or other imagery will exist as of the current moment, and will be added in a future time.</p></div><h3 id="heaps-1" tabindex="-1"><a class="header-anchor" href="#heaps-1"><span>Heaps</span></a></h3><ul><li>special kind of complete binary tree</li><li>two types: min heap and max heap <ul><li>min heap <ul><li>the root node has the minimum value</li><li>the value of each node is greater than or equal to the value of its parent node.</li></ul></li><li>max heap <ul><li>the root node has the maximum value</li><li>the value of each node is lesser than or equal to the value of its parent node.</li></ul></li></ul></li></ul><h3 id="heapq" tabindex="-1"><a class="header-anchor" href="#heapq"><span>heapq</span></a></h3><ul><li>built-in python module to implement a min-heap <ul><li>heapq.heapify <ul><li>converts a regular list to a heap</li></ul></li><li>heapq.heappush <ul><li>adds an element to the heap by adjusting the order to maintain heap structure</li></ul></li><li>heapq.heappop <ul><li>returns the smallest element to the heap, then adjusts the order to maintain heap structure</li></ul></li><li>heapq.heappushpop <ul><li>combines <code>heapq.heappush</code> and <code>heapq.heappop</code>, in that order. Heap structure is maintained after this operation.</li></ul></li><li>heapq.heapreplace <ul><li>removes the smallest element (<code>heapq.heappop</code>) and inserts a new item (<code>heapq.heappush</code>). Heap structure is maintained after this operation.</li></ul></li><li>heapq.nlargest <ul><li>gets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> largest elements from an iterable using the specified <code>key</code> to sort the elements <ul><li>a <code>key</code> is a function that you can <em>optionally</em> supply to control which property to sort on. (for example: <code>x[1]</code>)</li></ul></li></ul></li><li>heapq.nsmallest <ul><li>gets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> smallest elements from an iterable using the specified <code>key</code> to sort the elements <ul><li>a <code>key</code> is a function that you can <em>optionally</em> supply to control which property to sort on. (for example: <code>x[1]</code>)</li></ul></li></ul></li></ul></li></ul>',6))])}const x=o(u,[["render",m],["__file","heaps.html.vue"]]),b=JSON.parse('{"path":"/cs5/3/heaps.html","title":"Heaps","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[{"level":3,"title":"Table of Contents","slug":"table-of-contents","link":"#table-of-contents","children":[]}]},{"level":2,"title":"Notes Outline","slug":"notes-outline","link":"#notes-outline","children":[{"level":3,"title":"Heaps","slug":"heaps-1","link":"#heaps-1","children":[]},{"level":3,"title":"heapq","slug":"heapq","link":"#heapq","children":[]}]}],"git":{"updatedTime":1741096210000},"filePathRelative":"cs5/3/heaps.md"}');export{x as comp,b as data};
